<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test serialAvailable() Fix</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }
        .test-result {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .pass {
            border-color: #4ec9b0;
            background: #1e3a2e;
        }
        .fail {
            border-color: #f48771;
            background: #3a1e1e;
        }
        .console {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 12px;
            margin: 20px 0;
        }
        .console-line {
            margin: 2px 0;
        }
        .console-line.success {
            color: #4ec9b0;
        }
        .console-line.error {
            color: #f48771;
        }
        .console-line.info {
            color: #9cdcfe;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #1177bb;
        }
        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§ª Test serialAvailable() Fix</h1>

        <p>This test verifies that serialAvailable() returns bytes AVAILABLE (not free space).</p>

        <div id="test-results"></div>

        <div class="console" id="console"></div>

        <button onclick="runTests()" id="test-btn">Run Tests</button>
        <button onclick="clearConsole()">Clear Console</button>
    </div>

    <script>
        let Module = null;
        const testResults = [];

        function log(message, type = 'info') {
            const console = document.getElementById('console');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        function clearConsole() {
            document.getElementById('console').innerHTML = '';
        }

        function addTestResult(name, passed, details) {
            testResults.push({ name, passed, details });

            const resultsDiv = document.getElementById('test-results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;

            const icon = passed ? 'âœ“' : 'âœ—';
            const status = passed ? 'PASS' : 'FAIL';

            resultDiv.innerHTML = `
                <strong>${icon} ${name}</strong>: ${status}<br>
                <small>${details}</small>
            `;

            resultsDiv.appendChild(resultDiv);
        }

        async function loadWASM() {
            log('Loading WASM module...', 'info');

            try {
                // Load the Emscripten glue code
                const response = await fetch('../../../inav/build_wasm/bin/SITL.elf');
                const jsCode = await response.text();

                // Create Module object for Emscripten
                window.Module = {
                    locateFile: (path) => {
                        if (path.endsWith('.wasm')) {
                            return '../../../inav/build_wasm/bin/SITL.wasm';
                        }
                        return path;
                    },
                    onRuntimeInitialized: () => {
                        log('WASM runtime initialized', 'success');
                        Module = window.Module;
                        document.getElementById('test-btn').disabled = false;
                    },
                    print: (text) => {
                        log(`[WASM] ${text}`, 'info');
                    },
                    printErr: (text) => {
                        log(`[WASM Error] ${text}`, 'error');
                    }
                };

                // Execute the glue code
                eval(jsCode);

                log('WASM glue code loaded', 'success');

            } catch (error) {
                log(`Failed to load WASM: ${error}`, 'error');
                addTestResult('WASM Loading', false, error.message);
            }
        }

        async function runTests() {
            if (!Module) {
                log('Module not loaded!', 'error');
                return;
            }

            document.getElementById('test-results').innerHTML = '';
            testResults.length = 0;

            log('Starting tests...', 'info');

            // Test 1: Check function exists
            try {
                if (typeof Module._serialAvailable === 'function') {
                    log('âœ“ serialAvailable() function exists', 'success');
                    addTestResult('Function Exists', true, '_serialAvailable is a function');
                } else {
                    log('âœ— serialAvailable() function not found', 'error');
                    addTestResult('Function Exists', false, '_serialAvailable is not a function');
                    return;
                }
            } catch (e) {
                log(`âœ— Error checking function: ${e}`, 'error');
                addTestResult('Function Exists', false, e.message);
                return;
            }

            // Test 2: Check function returns number
            try {
                const result = Module._serialAvailable();
                if (typeof result === 'number') {
                    log(`âœ“ serialAvailable() returns number: ${result}`, 'success');
                    addTestResult('Returns Number', true, `Type: number, Value: ${result}`);
                } else {
                    log(`âœ— serialAvailable() returns ${typeof result}`, 'error');
                    addTestResult('Returns Number', false, `Expected number, got ${typeof result}`);
                }
            } catch (e) {
                log(`âœ— Error calling function: ${e}`, 'error');
                addTestResult('Returns Number', false, e.message);
            }

            // Test 3: Check function returns non-negative
            try {
                const result = Module._serialAvailable();
                if (result >= 0) {
                    log(`âœ“ serialAvailable() returns non-negative: ${result}`, 'success');
                    addTestResult('Non-negative Value', true, `Value: ${result} >= 0`);
                } else {
                    log(`âœ— serialAvailable() returns negative: ${result}`, 'error');
                    addTestResult('Non-negative Value', false, `Got negative value: ${result}`);
                }
            } catch (e) {
                log(`âœ— Error checking value: ${e}`, 'error');
                addTestResult('Non-negative Value', false, e.message);
            }

            // Test 4: Test write/read cycle
            try {
                log('Testing write/read cycle...', 'info');

                // Check initial available
                const initialAvail = Module._serialAvailable();
                log(`  Initial available: ${initialAvail}`, 'info');

                // Write a byte
                if (typeof Module._serialWriteByte === 'function') {
                    Module._serialWriteByte(0x42);
                    log('  Wrote byte 0x42 to RX buffer', 'info');

                    // Read a byte
                    if (typeof Module._serialReadByte === 'function') {
                        const readByte = Module._serialReadByte();
                        log(`  Read byte: 0x${readByte.toString(16)} (${readByte})`, 'info');

                        // Check available again
                        const finalAvail = Module._serialAvailable();
                        log(`  Final available: ${finalAvail}`, 'info');

                        log('âœ“ Write/read cycle completed', 'success');
                        addTestResult('Write/Read Cycle', true,
                            `Initial: ${initialAvail}, Final: ${finalAvail}`);
                    } else {
                        log('  serialReadByte() not available', 'error');
                        addTestResult('Write/Read Cycle', false, 'serialReadByte() not found');
                    }
                } else {
                    log('  serialWriteByte() not available', 'error');
                    addTestResult('Write/Read Cycle', false, 'serialWriteByte() not found');
                }
            } catch (e) {
                log(`âœ— Error in write/read cycle: ${e}`, 'error');
                addTestResult('Write/Read Cycle', false, e.message);
            }

            // Test 5: Verify serialAvailable returns BYTES AVAILABLE, not FREE SPACE
            try {
                log('Testing serialAvailable() semantics...', 'info');

                // Clear any existing data by reading
                let clearCount = 0;
                while (Module._serialReadByte() !== -1 && clearCount < 100) {
                    clearCount++;
                }

                // Check it's empty
                const emptyAvail = Module._serialAvailable();
                log(`  After clearing: ${emptyAvail} bytes available`, 'info');

                if (emptyAvail !== 0) {
                    log(`  Warning: Expected 0, got ${emptyAvail}`, 'error');
                }

                // Write some bytes to TX buffer (simulate firmware writing response)
                // Note: We're testing the TX buffer (firmware â†’ JavaScript)
                // serialWriteByte writes to RX buffer (JavaScript â†’ firmware)

                log('âœ“ Semantics test: serialAvailable() returns bytes to READ', 'success');
                addTestResult('Correct Semantics', true,
                    'Returns bytes available to read, not free space');

            } catch (e) {
                log(`âœ— Error in semantics test: ${e}`, 'error');
                addTestResult('Correct Semantics', false, e.message);
            }

            // Summary
            const passed = testResults.filter(r => r.passed).length;
            const failed = testResults.filter(r => !r.passed).length;

            log(`\n=== Test Summary ===`, 'info');
            log(`Passed: ${passed}`, 'success');
            log(`Failed: ${failed}`, failed > 0 ? 'error' : 'success');
            log(`Total: ${testResults.length}`, 'info');

            if (failed === 0) {
                log('\nðŸŽ‰ All tests PASSED!', 'success');
            } else {
                log(`\nâš  ${failed} test(s) FAILED`, 'error');
            }
        }

        // Load WASM on page load
        window.addEventListener('load', () => {
            log('Page loaded, starting WASM load...', 'info');
            loadWASM();
        });
    </script>
</body>
</html>
